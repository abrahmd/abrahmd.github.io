import numpy as np
import json
import math
import matplotlib.pyplot as plt
import skimage.io as skio
import skimage as sk
import cv2

"""
    Helper method generated by chatgpt.
"""
def show_images(images, titles=None, cols=3, same_scale=False):
    n = len(images)
    rows = math.ceil(n / cols)
    fig, axs = plt.subplots(rows, cols, figsize=(4*cols, 4*rows))
    axs = np.atleast_1d(axs).ravel()

    # Optional: consistent grayscale scaling across all images
    vmin = vmax = None
    if same_scale:
        vals = [im for im in images if im.ndim == 2]
        if vals:
            vmin = min(float(x.min()) for x in vals)
            vmax = max(float(x.max()) for x in vals)

    for i, im in enumerate(images):
        if im.ndim == 2:
            axs[i].imshow(im, cmap='gray', vmin=vmin, vmax=vmax)
        else:
            axs[i].imshow(im)  # RGB
        if titles: axs[i].set_title(titles[i])
        axs[i].axis('off')

    # Hide any empty slots
    for j in range(i+1, rows*cols):
        axs[j].axis('off')

    plt.tight_layout(); plt.show()

"""
im1_pts and im2_pts are nx2 matricies of coorespdonding x,y points of two images
Returns 3x3 homography matrix that will transform im1 to the plane of im2
"""
def computeH_1_to_2(im1_pts, im2_pts):
    
    A = []
    b = []
    for (x,y), (u,v) in zip(im1_pts, im2_pts):
        A.append([x, y, 1, 0, 0, 0, -u*x, -u*y])
        A.append([0, 0, 0, x, y, 1, -v*x, -v*y])

        b.append(u)
        b.append(v)

    A = np.array(A)
    b = np.array(b)

    H = np.linalg.lstsq(A, b)[0] ## 8 entries, must append 1
    H = np.append(H, 1)
    
    return H.reshape(3, 3)


def load_img_coorrespondences(path):
    with open(path, "r") as f:
        data = json.load(f)

        return data["im1Points"], data["im2Points"]
    

def warpImageNearestNeighbor(im, H):
    corners = np.array([[0,             0,              1],
                        [0,             im.shape[0]-1,  1],
                        [im.shape[1]-1, im.shape[0]-1,  1],
                        [im.shape[1]-1,  0,             1]]).T

    warped = H @ corners
    warped /= warped[2]

    x_min = math.floor(np.min(warped[0]))
    x_max = math.ceil(np.max(warped[0]))
    y_min = math.floor(np.min(warped[1]))
    y_max = math.ceil(np.max(warped[1]))

    H_inv = np.linalg.inv(H)

    im_warp = np.zeros((y_max-y_min, x_max-x_min, im.shape[2]))
    for y in range(im_warp.shape[0]):
        for x in range(im_warp.shape[1]):
            pt_src = H_inv @ np.array([x+x_min, y+y_min, 1])
            pt_src /= pt_src[2]

            src_x = int(round(float(pt_src[0])))
            src_y = int(round(float(pt_src[1])))
            if src_y >= 0 and src_y < im.shape[0] and src_x >= 0 and src_x < im.shape[1]:
                im_warp[y, x, :] = im[src_y, src_x, :]

    return im_warp 

def warpImageBilinear(im, H):
    corners = np.array([[0,             0,              1],
                        [0,             im.shape[0]-1,  1],
                        [im.shape[1]-1, im.shape[0]-1,  1],
                        [im.shape[1]-1,  0,             1]]).T

    warped = H @ corners
    warped /= warped[2]

    x_min = math.floor(np.min(warped[0]))
    x_max = math.ceil(np.max(warped[0]))
    y_min = math.floor(np.min(warped[1]))
    y_max = math.ceil(np.max(warped[1]))

    H_inv = np.linalg.inv(H)

    im_warp = np.zeros((y_max-y_min, x_max-x_min, im.shape[2]))

    for y in range(im_warp.shape[0]):
        for x in range(im_warp.shape[1]):
            pt_src = H_inv @ np.array([x+x_min, y+y_min, 1])
            pt_src /= pt_src[2]

            src_x_min = math.floor(pt_src[0])
            src_x_max = math.ceil(pt_src[0])
            src_y_min = math.floor(pt_src[1])
            src_y_max = math.ceil(pt_src[1])

            if 0 <= src_x_min and src_x_max < im.shape[1] and src_y_min >= 0 and src_y_max < im.shape[0]:
                f_x_ymin = (src_x_max - pt_src[0]) * im[src_y_min, src_x_min, :] + (pt_src[0] - src_x_min) * im[src_y_min, src_x_max, :]
                f_x_ymax = (src_x_max - pt_src[0]) * im[src_y_max, src_x_min, :] + (pt_src[0] - src_x_min) * im[src_y_max, src_x_max, :]

                f_x_y = (src_y_max - pt_src[1]) * f_x_ymin + (pt_src[1] - src_y_min) * f_x_ymax
                im_warp[y, x, :] = f_x_y

    return im_warp 

def putImgOnCanvas(im, w_canvas, h_canvas, H_im_to_canvas):
    canvas = np.zeros((h_canvas, w_canvas, 3), dtype=np.float32)

    H_inv = np.linalg.inv(H_im_to_canvas)

    for y in range(canvas.shape[0]):
        for x in range(canvas.shape[1]):
            pt_src = H_inv @ np.array([x, y, 1])
            pt_src /= pt_src[2]

            src_x_min = math.floor(pt_src[0])
            src_y_min = math.floor(pt_src[1])
            src_x_max = src_x_min + 1
            src_y_max = src_y_min + 1

            if 0 <= src_x_min and src_x_max < im.shape[1] and src_y_min >= 0 and src_y_max < im.shape[0]:
                f_x_ymin = (src_x_max - pt_src[0]) * im[src_y_min, src_x_min, :] + (pt_src[0] - src_x_min) * im[src_y_min, src_x_max, :]
                f_x_ymax = (src_x_max - pt_src[0]) * im[src_y_max, src_x_min, :] + (pt_src[0] - src_x_min) * im[src_y_max, src_x_max, :]

                f_x_y = (src_y_max - pt_src[1]) * f_x_ymin + (pt_src[1] - src_y_min) * f_x_ymax
                canvas[y, x, :] = f_x_y

    return canvas 

def rectify():
    im1_pts, im2_pts = load_img_coorrespondences("data/IMG_2872_rect.json")

    H_1_to_2 = computeH_1_to_2(im1_pts, im2_pts)

    imname = 'data/IMG_2872.jpeg'

    im = skio.imread(imname) 
    im = im.astype(np.float32) / 255.0

    im_warp = warpImageBilinear(im, H_1_to_2)

    plt.imsave('data/rectified_photo2.jpg', im_warp)

    plt.imshow(im_warp)
    plt.show()

def create_canvas(im1_shape, im2_shape, H_1_to_2):
    h1, w1 = im1_shape[:2]
    h2, w2 = im2_shape[:2]

    corners_1 = np.array([[0, 0, 1], [w1, 0, 1], [w1, h1, 1], [0, h1, 1]], dtype=np.float32).T
    corners_1_warped = H_1_to_2 @ corners_1
    corners_1_warped /= corners_1_warped[2]
    corners_1_warped = corners_1_warped[:2].T

    corners2 = np.array([[0, 0], [w2, 0], [w2, h2], [0, h2]], dtype=np.float32)

    all_corners = np.vstack([corners_1_warped, corners2])

    x_min = math.floor(all_corners[:,0].min())
    x_max = math.ceil(all_corners[:,0].max())
    y_min = math.floor(all_corners[:,1].min())
    y_max = math.ceil(all_corners[:,1].max())

    T = np.array([[1, 0, -x_min], 
                  [0, 1, -y_min], 
                  [0, 0,      1]], dtype=np.float32)

    return T, x_max-x_min, y_max-y_min


def stitch_alphablend(im1, im2, H_1_to_2):
    T, w_canvas, h_canvas = create_canvas(im1.shape, im2.shape, H_1_to_2)

    H_im1_to_canvas = T @ H_1_to_2
    H_im2_to_canvas = T

    im1_canvas = putImgOnCanvas(im1, w_canvas, h_canvas, H_im1_to_canvas)
    im2_canvas = putImgOnCanvas(im2, w_canvas, h_canvas, H_im2_to_canvas)

    alpha_1 = np.any(im1_canvas > 0, axis=-1).astype(np.float32)
    alpha_2 = np.any(im2_canvas > 0, axis=-1).astype(np.float32)
    
    alpha_1 = np.stack([alpha_1, alpha_1, alpha_1], axis=2)
    alpha_2 = np.stack([alpha_2, alpha_2, alpha_2], axis=2)

    total = alpha_1 + alpha_2
    total[total == 0] = 1

    blended_image = (im1_canvas * alpha_1 + im2_canvas * alpha_2) / total 

    return blended_image, H_im2_to_canvas

def mosaic(im1_name, im2_name, im1_pts, im2_pts):
    H_1_to_2 = computeH_1_to_2(im1_pts, im2_pts)

    im1 = skio.imread(im1_name) 
    im2 = skio.imread(im2_name)

    im1 = im1.astype(np.float32) / 255.0
    im2 = im2.astype(np.float32) / 255.0

    im1_warp = warpImageNearestNeighbor(im1, H_1_to_2)

    return im1, im1_warp, im2, H_1_to_2

def cylindrical_warp(im, focal_length):
    width_cyl = int(np.ceil(2.0 * focal_length * np.arctan((im.shape[1] / 2.0) / focal_length)))
    height_cyl = im.shape[0]

    y_cyl, x_cyl = np.indices((height_cyl, width_cyl), dtype=np.float32)
    x_cyl -= (width_cyl - 1) / 2.0
    y_cyl -= (height_cyl - 1) / 2.0

    canvas = np.full((height_cyl, width_cyl, im.shape[2]), 0.0, dtype=np.float32)

    x_src_center = np.int32((im.shape[1] - 1) / 2.0)
    y_src_center = np.int32((im.shape[0] - 1) / 2.0)

    x_cyl_center = np.int32((width_cyl - 1) / 2.0)
    y_cyl_center = np.int32((height_cyl - 1) / 2.0)

    for y in range(height_cyl):
        y_cyl = y - y_cyl_center
        for x in range(width_cyl):
            x_cyl = x - x_cyl_center

            theta = x_cyl / focal_length
            if math.cos(theta) < 1e-9: continue

            x_src = x_src_center + focal_length * math.tan(theta)
            y_src = y_src_center + y_cyl * (1.0 / math.cos(theta))

            x_min = math.floor(x_src)
            x_max = x_min + 1
            y_min = math.floor(y_src)
            y_max = y_min + 1

            if x_min >= 0 and x_max < im.shape[1] and y_min >= 0 and y_max < im.shape[0]:
                f_x_ymin = (x_max - x_src) * im[y_min, x_min, :] + (x_src - x_min) * im[y_min, x_max, :]
                f_x_ymax = (x_max - x_src) * im[y_max, x_min, :] + (x_src - x_min) * im[y_max, x_max, :]

                f_x_y = (y_max - y_src) * f_x_ymin + (y_src - y_min) * f_x_ymax
                canvas[y, x, :] = f_x_y

    return canvas

def xy_to_cyl(points, focal_length, x_center, y_center):
    x = points[:, 0].astype(np.float32)
    y = points[:, 1].astype(np.float32)

    x -= x_center
    y -= y_center

    theta = np.arctan2(x, focal_length)

    x_cyl = focal_length * theta
    y_cyl = y * (focal_length / np.sqrt(x*x + focal_length*focal_length))

    cylindrical_points = np.stack([x_cyl, y_cyl], axis=1)
    return cylindrical_points


def translate_cyl_imgs(im1_pts, im2_pts, im1, im2, focal_length):
    h1, w1 = im1.shape[:2]
    h2, w2 = im2.shape[:2]

    x1_center = (w1 - 1) / 2.0
    y1_center = (h1 - 1) / 2.0

    x2_center = (w2 - 1) / 2.0
    y2_center = (h2 - 1) / 2.0

    im1_cyl_pts = xy_to_cyl(im1_pts, focal_length, x1_center, y1_center)
    im2_cyl_pts = xy_to_cyl(im2_pts, focal_length, x2_center, y2_center)

    dx = np.median(im2_cyl_pts[:, 0] - im1_cyl_pts[:, 0])
    dy = np.median(im2_cyl_pts[:, 1] - im1_cyl_pts[:, 1])
    
    H_1_to_2_cyl = np.array([[1, 0, dx],
                             [0, 1, dy],
                             [0, 0, 1]]).astype(np.float32)
    return H_1_to_2_cyl

    
def cylindrical_mosaic():
    im1_name = 'data/neighborhood/IMG_2885.jpg'
    im2_name = 'data/neighborhood/IMG_2886.jpg'

    im1_pts, im2_pts = load_img_coorrespondences("data/neighborhood/IMG_2885_IMG_2886.json")

    im1_pts = np.array(im1_pts)
    im2_pts = np.array(im2_pts)
    #H_1_to_2 = computeH_1_to_2(im1_pts, im2_pts)

    im1 = skio.imread(im1_name) 
    im2 = skio.imread(im2_name)

    im1 = im1.astype(np.float32) / 255.0
    im2 = im2.astype(np.float32) / 255.0

    focal_length = im1.shape[1] * 0.8
    im1_cyl = cylindrical_warp(im1, focal_length)
    im2_cyl = cylindrical_warp(im2, focal_length)

    H_1_to_2_cyl = translate_cyl_imgs(im1_pts, im2_pts, im1, im2, focal_length)

    blend, H_im2_to_canvas = stitch_alphablend(im1_cyl, im2_cyl, H_1_to_2_cyl)

    plt.imsave('data/neighborhood/cylinderim1.jpg', im1_cyl)
    plt.imsave('data/neighborhood/cylinderim2.jpg', im2_cyl)
    plt.imsave('data/neighborhood/cylinderblend.jpg', blend)

    show_images([im1, im2, im1_cyl, im2_cyl, blend])


def partA3():
    im1_name = 'data/neighborhood/IMG_2885.jpg'
    im2_name = 'data/neighborhood/IMG_2886.jpg'
    im3_name = 'data/neighborhood/IMG_2887.jpg'

    im1_pts, im2_pts = load_img_coorrespondences("data/neighborhood/IMG_2885_IMG_2886.json")
    im1, im1_warp, im2, H_1_to_2 = mosaic(im1_name, im2_name, im1_pts, im2_pts)

    im3_pts, im2_pts2 = load_img_coorrespondences("data/neighborhood/IMG_2887_IMG_2886.json")
    im3, im3_warp, im2, H_3_to_2 = mosaic(im3_name, im2_name, im3_pts, im2_pts2)

    show_images([im1, im2, im1_warp, im3_warp])

    #blend = stitch_alphablend(im1, im2, H_1_to_2)

def partA4():
    im1_name = 'data/tennis/IMG_2891.jpg'
    im2_name = 'data/tennis/IMG_2892.jpg'
    im3_name = 'data/tennis/IMG_2893.jpg'

    im1_pts, im2_pts = load_img_coorrespondences("data/tennis/IMG_2891_IMG_2892.json")
    im1, im1_warp, im2, H_1_to_2 = mosaic(im1_name, im2_name, im1_pts, im2_pts)

    blend, H_im2_to_canvas = stitch_alphablend(im1, im2, H_1_to_2)

    im3_pts, im2_pts2 = load_img_coorrespondences("data/tennis/IMG_2893_IMG_2892.json")
    im3, im3_warp, im2, H_3_to_2 = mosaic(im3_name, im2_name, im3_pts, im2_pts2)

    full_blend, _ = stitch_alphablend(im3, blend, H_im2_to_canvas @ H_3_to_2)

    plt.imsave('data/tennis/full_blend.jpg', full_blend)

    show_images([im1, im1_warp, im2, im3, im3_warp, full_blend])


    


#partA3()
#partA4()
#mosaic()
#cylindrical_mosaic()
#rectify()








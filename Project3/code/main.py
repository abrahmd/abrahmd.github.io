import numpy as np
import json
import math
import matplotlib.pyplot as plt
import skimage.io as skio
import skimage as sk
import cv2
import random
#from skimage.feature import corner_harris, peak_local_max

from harris import get_harris_corners, dist2

"""
    Helper method generated by chatgpt.
"""
def show_images(images, titles=None, cols=3, same_scale=False):
    n = len(images)
    rows = math.ceil(n / cols)
    fig, axs = plt.subplots(rows, cols, figsize=(4*cols, 4*rows))
    axs = np.atleast_1d(axs).ravel()

    # Optional: consistent grayscale scaling across all images
    vmin = vmax = None
    if same_scale:
        vals = [im for im in images if im.ndim == 2]
        if vals:
            vmin = min(float(x.min()) for x in vals)
            vmax = max(float(x.max()) for x in vals)

    for i, im in enumerate(images):
        if im.ndim == 2:
            axs[i].imshow(im, cmap='gray', vmin=vmin, vmax=vmax)
        else:
            axs[i].imshow(im)  # RGB
        if titles: axs[i].set_title(titles[i])
        axs[i].axis('off')

    # Hide any empty slots
    for j in range(i+1, rows*cols):
        axs[j].axis('off')

    plt.tight_layout(); plt.show()

"""
im1_pts and im2_pts are nx2 matricies of coorespdonding x,y points of two images
Returns 3x3 homography matrix that will transform im1 to the plane of im2
"""
def computeH_1_to_2(im1_pts, im2_pts):
    
    A = []
    b = []
    for (x,y), (u,v) in zip(im1_pts, im2_pts):
        A.append([x, y, 1, 0, 0, 0, -u*x, -u*y])
        A.append([0, 0, 0, x, y, 1, -v*x, -v*y])

        b.append(u)
        b.append(v)

    A = np.array(A)
    b = np.array(b)

    H = np.linalg.lstsq(A, b)[0] ## 8 entries, must append 1
    H = np.append(H, 1)
    
    return H.reshape(3, 3)


def load_img_coorrespondences(path):
    with open(path, "r") as f:
        data = json.load(f)

        return data["im1Points"], data["im2Points"]
    

def warpImageNearestNeighbor(im, H):
    corners = np.array([[0,             0,              1],
                        [0,             im.shape[0]-1,  1],
                        [im.shape[1]-1, im.shape[0]-1,  1],
                        [im.shape[1]-1,  0,             1]]).T

    warped = H @ corners
    warped /= warped[2]

    x_min = math.floor(np.min(warped[0]))
    x_max = math.ceil(np.max(warped[0]))
    y_min = math.floor(np.min(warped[1]))
    y_max = math.ceil(np.max(warped[1]))

    H_inv = np.linalg.inv(H)

    im_warp = np.zeros((y_max-y_min, x_max-x_min, im.shape[2]))
    for y in range(im_warp.shape[0]):
        for x in range(im_warp.shape[1]):
            pt_src = H_inv @ np.array([x+x_min, y+y_min, 1])
            pt_src /= pt_src[2]

            src_x = int(round(float(pt_src[0])))
            src_y = int(round(float(pt_src[1])))
            if src_y >= 0 and src_y < im.shape[0] and src_x >= 0 and src_x < im.shape[1]:
                im_warp[y, x, :] = im[src_y, src_x, :]

    return im_warp 

def warpImageBilinear(im, H):
    corners = np.array([[0,             0,              1],
                        [0,             im.shape[0]-1,  1],
                        [im.shape[1]-1, im.shape[0]-1,  1],
                        [im.shape[1]-1,  0,             1]]).T

    warped = H @ corners
    warped /= warped[2]

    x_min = math.floor(np.min(warped[0]))
    x_max = math.ceil(np.max(warped[0]))
    y_min = math.floor(np.min(warped[1]))
    y_max = math.ceil(np.max(warped[1]))

    H_inv = np.linalg.inv(H)

    im_warp = np.zeros((y_max-y_min, x_max-x_min, im.shape[2]))

    for y in range(im_warp.shape[0]):
        for x in range(im_warp.shape[1]):
            pt_src = H_inv @ np.array([x+x_min, y+y_min, 1])
            pt_src /= pt_src[2]

            src_x_min = math.floor(pt_src[0])
            src_x_max = math.ceil(pt_src[0])
            src_y_min = math.floor(pt_src[1])
            src_y_max = math.ceil(pt_src[1])

            if 0 <= src_x_min and src_x_max < im.shape[1] and src_y_min >= 0 and src_y_max < im.shape[0]:
                f_x_ymin = (src_x_max - pt_src[0]) * im[src_y_min, src_x_min, :] + (pt_src[0] - src_x_min) * im[src_y_min, src_x_max, :]
                f_x_ymax = (src_x_max - pt_src[0]) * im[src_y_max, src_x_min, :] + (pt_src[0] - src_x_min) * im[src_y_max, src_x_max, :]

                f_x_y = (src_y_max - pt_src[1]) * f_x_ymin + (pt_src[1] - src_y_min) * f_x_ymax
                im_warp[y, x, :] = f_x_y

    return im_warp 

def putImgOnCanvas(im, w_canvas, h_canvas, H_im_to_canvas):
    canvas = np.zeros((h_canvas, w_canvas, 3), dtype=np.float32)

    H_inv = np.linalg.inv(H_im_to_canvas)

    for y in range(canvas.shape[0]):
        for x in range(canvas.shape[1]):
            pt_src = H_inv @ np.array([x, y, 1])
            pt_src /= pt_src[2]

            src_x_min = math.floor(pt_src[0])
            src_y_min = math.floor(pt_src[1])
            src_x_max = src_x_min + 1
            src_y_max = src_y_min + 1

            if 0 <= src_x_min and src_x_max < im.shape[1] and src_y_min >= 0 and src_y_max < im.shape[0]:
                f_x_ymin = (src_x_max - pt_src[0]) * im[src_y_min, src_x_min, :] + (pt_src[0] - src_x_min) * im[src_y_min, src_x_max, :]
                f_x_ymax = (src_x_max - pt_src[0]) * im[src_y_max, src_x_min, :] + (pt_src[0] - src_x_min) * im[src_y_max, src_x_max, :]

                f_x_y = (src_y_max - pt_src[1]) * f_x_ymin + (pt_src[1] - src_y_min) * f_x_ymax
                canvas[y, x, :] = f_x_y

    return canvas 

def rectify():
    im1_pts, im2_pts = load_img_coorrespondences("data/IMG_2872_rect.json")

    H_1_to_2 = computeH_1_to_2(im1_pts, im2_pts)

    imname = 'data/IMG_2872.jpeg'

    im = skio.imread(imname) 
    im = im.astype(np.float32) / 255.0

    im_warp = warpImageBilinear(im, H_1_to_2)

    plt.imsave('data/rectified_photo2.jpg', im_warp)

    plt.imshow(im_warp)
    plt.show()

def create_canvas(im1_shape, im2_shape, H_1_to_2):
    h1, w1 = im1_shape[:2]
    h2, w2 = im2_shape[:2]

    corners_1 = np.array([[0, 0, 1], [w1, 0, 1], [w1, h1, 1], [0, h1, 1]], dtype=np.float32).T
    corners_1_warped = H_1_to_2 @ corners_1
    corners_1_warped /= corners_1_warped[2]
    corners_1_warped = corners_1_warped[:2].T

    corners2 = np.array([[0, 0], [w2, 0], [w2, h2], [0, h2]], dtype=np.float32)

    all_corners = np.vstack([corners_1_warped, corners2])

    x_min = math.floor(all_corners[:,0].min())
    x_max = math.ceil(all_corners[:,0].max())
    y_min = math.floor(all_corners[:,1].min())
    y_max = math.ceil(all_corners[:,1].max())

    T = np.array([[1, 0, -x_min], 
                  [0, 1, -y_min], 
                  [0, 0,      1]], dtype=np.float32)

    return T, x_max-x_min, y_max-y_min


def stitch_alphablend(im1, im2, H_1_to_2):
    T, w_canvas, h_canvas = create_canvas(im1.shape, im2.shape, H_1_to_2)

    H_im1_to_canvas = T @ H_1_to_2
    H_im2_to_canvas = T

    im1_canvas = putImgOnCanvas(im1, w_canvas, h_canvas, H_im1_to_canvas)
    im2_canvas = putImgOnCanvas(im2, w_canvas, h_canvas, H_im2_to_canvas)

    alpha_1 = np.any(im1_canvas > 0, axis=-1).astype(np.float32)
    alpha_2 = np.any(im2_canvas > 0, axis=-1).astype(np.float32)
    
    alpha_1 = np.stack([alpha_1, alpha_1, alpha_1], axis=2)
    alpha_2 = np.stack([alpha_2, alpha_2, alpha_2], axis=2)

    total = alpha_1 + alpha_2
    total[total == 0] = 1

    blended_image = (im1_canvas * alpha_1 + im2_canvas * alpha_2) / total 

    return blended_image, H_im2_to_canvas

def mosaic(im1_name, im2_name, im1_pts, im2_pts):
    H_1_to_2 = computeH_1_to_2(im1_pts, im2_pts)

    im1 = skio.imread(im1_name) 
    im2 = skio.imread(im2_name)

    im1 = im1.astype(np.float32) / 255.0
    im2 = im2.astype(np.float32) / 255.0

    im1_warp = warpImageNearestNeighbor(im1, H_1_to_2)

    return im1, im1_warp, im2, H_1_to_2

def cylindrical_warp(im, focal_length):
    width_cyl = int(np.ceil(2.0 * focal_length * np.arctan((im.shape[1] / 2.0) / focal_length)))
    height_cyl = im.shape[0]

    y_cyl, x_cyl = np.indices((height_cyl, width_cyl), dtype=np.float32)
    x_cyl -= (width_cyl - 1) / 2.0
    y_cyl -= (height_cyl - 1) / 2.0

    canvas = np.full((height_cyl, width_cyl, im.shape[2]), 0.0, dtype=np.float32)

    x_src_center = np.int32((im.shape[1] - 1) / 2.0)
    y_src_center = np.int32((im.shape[0] - 1) / 2.0)

    x_cyl_center = np.int32((width_cyl - 1) / 2.0)
    y_cyl_center = np.int32((height_cyl - 1) / 2.0)

    for y in range(height_cyl):
        y_cyl = y - y_cyl_center
        for x in range(width_cyl):
            x_cyl = x - x_cyl_center

            theta = x_cyl / focal_length
            if math.cos(theta) < 1e-9: continue

            x_src = x_src_center + focal_length * math.tan(theta)
            y_src = y_src_center + y_cyl * (1.0 / math.cos(theta))

            x_min = math.floor(x_src)
            x_max = x_min + 1
            y_min = math.floor(y_src)
            y_max = y_min + 1

            if x_min >= 0 and x_max < im.shape[1] and y_min >= 0 and y_max < im.shape[0]:
                f_x_ymin = (x_max - x_src) * im[y_min, x_min, :] + (x_src - x_min) * im[y_min, x_max, :]
                f_x_ymax = (x_max - x_src) * im[y_max, x_min, :] + (x_src - x_min) * im[y_max, x_max, :]

                f_x_y = (y_max - y_src) * f_x_ymin + (y_src - y_min) * f_x_ymax
                canvas[y, x, :] = f_x_y

    return canvas

def xy_to_cyl(points, focal_length, x_center, y_center):
    x = points[:, 0].astype(np.float32)
    y = points[:, 1].astype(np.float32)

    x -= x_center
    y -= y_center

    theta = np.arctan2(x, focal_length)

    x_cyl = focal_length * theta
    y_cyl = y * (focal_length / np.sqrt(x*x + focal_length*focal_length))

    cylindrical_points = np.stack([x_cyl, y_cyl], axis=1)
    return cylindrical_points


def translate_cyl_imgs(im1_pts, im2_pts, im1, im2, focal_length):
    h1, w1 = im1.shape[:2]
    h2, w2 = im2.shape[:2]

    x1_center = (w1 - 1) / 2.0
    y1_center = (h1 - 1) / 2.0

    x2_center = (w2 - 1) / 2.0
    y2_center = (h2 - 1) / 2.0

    im1_cyl_pts = xy_to_cyl(im1_pts, focal_length, x1_center, y1_center)
    im2_cyl_pts = xy_to_cyl(im2_pts, focal_length, x2_center, y2_center)

    dx = np.median(im2_cyl_pts[:, 0] - im1_cyl_pts[:, 0])
    dy = np.median(im2_cyl_pts[:, 1] - im1_cyl_pts[:, 1])
    
    H_1_to_2_cyl = np.array([[1, 0, dx],
                             [0, 1, dy],
                             [0, 0, 1]]).astype(np.float32)
    return H_1_to_2_cyl

    
def cylindrical_mosaic():
    im1_name = 'data/neighborhood/IMG_2885.jpg'
    im2_name = 'data/neighborhood/IMG_2886.jpg'

    im1_pts, im2_pts = load_img_coorrespondences("data/neighborhood/IMG_2885_IMG_2886.json")

    im1_pts = np.array(im1_pts)
    im2_pts = np.array(im2_pts)
    #H_1_to_2 = computeH_1_to_2(im1_pts, im2_pts)

    im1 = skio.imread(im1_name) 
    im2 = skio.imread(im2_name)

    im1 = im1.astype(np.float32) / 255.0
    im2 = im2.astype(np.float32) / 255.0

    focal_length = im1.shape[1] * 0.8
    im1_cyl = cylindrical_warp(im1, focal_length)
    im2_cyl = cylindrical_warp(im2, focal_length)

    H_1_to_2_cyl = translate_cyl_imgs(im1_pts, im2_pts, im1, im2, focal_length)

    blend, H_im2_to_canvas = stitch_alphablend(im1_cyl, im2_cyl, H_1_to_2_cyl)

    plt.imsave('data/neighborhood/cylinderim1.jpg', im1_cyl)
    plt.imsave('data/neighborhood/cylinderim2.jpg', im2_cyl)
    plt.imsave('data/neighborhood/cylinderblend.jpg', blend)

    show_images([im1, im2, im1_cyl, im2_cyl, blend])


def partA3():
    im1_name = 'data/neighborhood/IMG_2885.jpg'
    im2_name = 'data/neighborhood/IMG_2886.jpg'
    im3_name = 'data/neighborhood/IMG_2887.jpg'

    im1_pts, im2_pts = load_img_coorrespondences("data/neighborhood/IMG_2885_IMG_2886.json")
    im1, im1_warp, im2, H_1_to_2 = mosaic(im1_name, im2_name, im1_pts, im2_pts)

    im3_pts, im2_pts2 = load_img_coorrespondences("data/neighborhood/IMG_2887_IMG_2886.json")
    im3, im3_warp, im2, H_3_to_2 = mosaic(im3_name, im2_name, im3_pts, im2_pts2)

    show_images([im1, im2, im1_warp, im3_warp])

    #blend = stitch_alphablend(im1, im2, H_1_to_2)

def partA4():
    im1_name = 'data/tennis/IMG_2891.jpg'
    im2_name = 'data/tennis/IMG_2892.jpg'
    im3_name = 'data/tennis/IMG_2893.jpg'

    im1_pts, im2_pts = load_img_coorrespondences("data/tennis/IMG_2891_IMG_2892.json")
    im1, im1_warp, im2, H_1_to_2 = mosaic(im1_name, im2_name, im1_pts, im2_pts)

    blend, H_im2_to_canvas = stitch_alphablend(im1, im2, H_1_to_2)

    im3_pts, im2_pts2 = load_img_coorrespondences("data/tennis/IMG_2893_IMG_2892.json")
    im3, im3_warp, im2, H_3_to_2 = mosaic(im3_name, im2_name, im3_pts, im2_pts2)

    full_blend, _ = stitch_alphablend(im3, blend, H_im2_to_canvas @ H_3_to_2)

    plt.imsave('data/tennis/full_blend.jpg', full_blend)

    show_images([im1, im1_warp, im2, im3, im3_warp, full_blend])

def ANMS(h, coords, num_intpts, c_robust=0.9):
    N = len(coords)

    strengths = h[coords[:,0], coords[:,1]]

    strengths = np.array(strengths)
    order = np.argsort(-strengths)

    strengths = strengths[order]
    coords = coords[order]

    radii = np.full(N, np.inf, dtype=np.float32)
    
    for i in range(1, N):
        mask = strengths[i] < c_robust * strengths[:i]
        if np.any(mask): 
            d2 = dist2(np.array([coords[i]]), coords[:i][mask]) 
            radii[i] = np.min(d2)
        
    order_r = np.argsort(-radii)
    pts_maxr = coords[order_r]

    return pts_maxr[:num_intpts]

def partB1():
    im_name = 'data/studying/IMG_2932.jpeg'
    im = skio.imread(im_name) 
    im = im.astype(np.float32) / 255.0

    h, coords = get_harris_corners(im[:,:,0])
    
    points = ANMS(h, coords.T, 100) #in format np array: [[y,x], [y1,x1], [y2,2x]...[yn,xn]]

    radius = 8
    for y, x in points:
        cv2.circle(im, (x, y), radius, (1,0,0),   thickness=-1, lineType=cv2.LINE_AA)

    #plt.imsave('data/studying/IMG_2932_HC_100.jpg', im)
    show_images([im])
    

def gaussian_pyramid(im, K) -> list:
    pyramid = [im]
    for i in range(K-1):
        im2 = cv2.resize(im, (int(im.shape[1] / 2), int(im.shape[0] / 2)))
        pyramid.append(im2)
        im = im2
    return pyramid


def get_feature_samples(im, interest_points):
    im_pyramid_level2 = np.array(gaussian_pyramid(im, 2)[1])
    samples = []
    windows = []
    for k in range(len(interest_points)):
        y, x = interest_points[k]
        xk = int(x / 2)
        yk = int(y / 2)

        sample = np.zeros((8,8)) 
        for i in range(8): # centering xk yk at 4,4 in the sample
            for j in range(8): 
                sample[i, j] = im_pyramid_level2[yk - i + 4, xk - j + 4]

        sample_mean = np.mean(sample)
        sample_std = np.std(sample)
        sample = sample - sample_mean
        sample = sample / (sample_std + 1e-9)
        samples.append(sample)

    return samples

def get_rotation_invariant_feature_samples(im, interest_points):
    im2 = np.array(gaussian_pyramid(im, 2)[1])
    samples = []
    for y, x in interest_points:
        y = int(y/2)
        x = int(x/2) #all on second pyramid level

        radius = 3

        y0 = max(0, y-radius)
        y1 = min(im2.shape[0]-1, y+radius)
        x0 = max(0, x-radius)
        x1 = min(im2.shape[1]-1, x+radius)
        patch = im2[y0:y1+1, x0:x1+1]

        dx = cv2.Sobel(patch, cv2.CV_32F, 1, 0)
        dy = cv2.Sobel(patch, cv2.CV_32F, 0, 1)

        magnitude = np.hypot(dx, dy)
        rotation_angle = (np.arctan2(dy, dx) + 2*np.pi).ravel()
        rotation_angle = rotation_angle % (2*np.pi)
        
        yy, xx = np.mgrid[y0:y1+1, x0:x1+1]
        gaussian_spatial_weight = np.exp(-(((xx - x))**2 + (yy - y)**2) / 9).astype(np.float32) #
        votes = (magnitude * gaussian_spatial_weight).ravel()

        # 36 bin histogram
        bins = 36
        histogram = np.zeros(bins, np.float32)
        b_max = rotation_angle * (bins / (2*np.pi))
        b_0 = (np.floor(b_max).astype(np.int32)) % bins
        for i, vote in zip(b_0, votes):
            histogram[i] += float(vote)

        theta = (int(histogram.argmax()) + 0.5) * 2 * np.pi / bins
        #thetas.append(theta)

        ## use theta on the sample 
        cos_theta = np.cos(theta)
        sin_theta = np.sin(theta)
        
        y_offsets, x_offsets = np.mgrid[-3:4, -3:4]
        X = x + cos_theta*x_offsets - sin_theta*y_offsets
        Y = y + sin_theta*x_offsets + cos_theta*y_offsets

        sample = cv2.remap(im2, X.astype(np.float32), Y.astype(np.float32), interpolation=cv2.INTER_LINEAR, borderMode=cv2.BORDER_REFLECT_101).astype(np.float32)

        #normalize
        sample_mean = np.mean(sample)
        sample_std = np.std(sample)
        sample = sample - sample_mean
        sample = sample / (sample_std + 1e-9)

        samples.append(sample)
    
    return samples



def partB2():
    im_name = 'data/studying/IMG_2932.jpeg'
    im = skio.imread(im_name, as_gray=True) 
    im = im.astype(np.float32) / 255.0

    h, coords = get_harris_corners(im)
    interest_points = ANMS(h, coords.T, 500) #in format np array: [[y,x], [y1,x1], [y2,2x]...[yn,xn]]

    ## new for part B
    #samples = get_feature_samples(im, interest_points)
    samples = get_rotation_invariant_feature_samples(im, interest_points)

    show_images([samples[0], samples[1]])

    ## sample 8x8 grid around each interest point
    
    """
    if k % 32 == 0: #Helper from chatgpt to show numbers on the image
        dot_center = (x, y)  # (x, y) coordinates
        dot_radius = 8          # radius in pixels
        dot_color = (0, 0, 255)  # Red in BGR format
        dot_thickness = -1       # -1 means fill the circle

        # Define the text properties
        text_to_display = str(k//32)
        text_font = cv2.FONT_HERSHEY_SIMPLEX
        text_font_scale = 5
        text_color = (0, 0, 255)
        text_thickness = 5

        # --- Draw the dot and number on the image ---

        # 1. Draw the dot
        cv2.circle(im, dot_center, dot_radius, dot_color, dot_thickness)

        # 2. Place the text next to the dot
        # The text origin is the bottom-left corner of the text string.
        # We offset the text from the dot's center to position it correctly.
        text_offset_x = dot_center[0] + 10
        text_offset_y = dot_center[1] + 5
        text_origin = (text_offset_x, text_offset_y)
        cv2.putText(im, text_to_display, text_origin, text_font, text_font_scale, text_color, text_thickness)
    #plt.imsave(f'data/studying/IMG_2932_nums.jpg', im, cmap='gray')
    """

def dist2_pair(a, b):
    return float(np.sum((a-b)**2))

def nearest_neighbors12(samples1, samples2, interest_points2):
    nn12 =  [[0,0] for i in range(len(samples1))]
    nn12_distances = [[np.inf,np.inf] for i in range(len(samples1))]

    for i in range(len(samples1)):
        s1 = samples1[i]
        for j in range(len(samples2)):
            s2 = samples2[j]
            d2 = dist2_pair(s1, s2)
            if d2 < nn12_distances[i][0]:
                nn12_distances[i][1] = nn12_distances[i][0]
                nn12_distances[i][0] = d2

                nn12[i][1] = nn12[i][0]
                nn12[i][0] = interest_points2[j]
            elif d2 < nn12_distances[i][1]:
                nn12_distances[i][1] = d2
                nn12[i][1] = interest_points2[j]
    return nn12, nn12_distances


def lowe_ratio(nn12_distances):
    return np.array([nn12_distances[i][0] / nn12_distances[i][1] for i in range(len(nn12_distances))])

def draw_images_side_by_side(im1, pts1, im2, pts2):
    h, w = im1.shape[:2]
    canvas = np.hstack([im1, im2])
    offset = w

    for i in range(len(pts1)):
        c = (1, 0, 0)
        y1, x1 = pts1[i]
        y2, x2 = pts2[i]
        x2 += offset
        cv2.line(canvas, (x1, y1), (x2, y2), c, thickness=2, lineType=cv2.LINE_AA)
        radius = 8
        cv2.circle(canvas, (x1, y1), radius, (1,0,0),   thickness=-1, lineType=cv2.LINE_AA)
        cv2.circle(canvas, (x2, y2), radius, (1,0,0),   thickness=-1, lineType=cv2.LINE_AA)
    
    return canvas

def partB3():
    im1name = 'data/library/IMG_2875.jpg'
    im1 = skio.imread(im1name, as_gray=True) 
    im1 = im1.astype(np.float32) / 255.0

    im2name = 'data/library/IMG_2876.jpeg'
    im2 = skio.imread(im2name, as_gray=True) 
    im2 = im2.astype(np.float32) / 255.0

    h1, coords1 = get_harris_corners(im1)
    interest_points1 = ANMS(h1, coords1.T, 500)
    samples1 = get_feature_samples(im1, interest_points1)

    h2, coords2 = get_harris_corners(im2)
    interest_points2 = ANMS(h2, coords2.T, 500)
    samples2 = get_feature_samples(im2, interest_points2)

    nn12, nn12_distances = nearest_neighbors12(samples1, samples2, interest_points2)
    lowe_r = lowe_ratio(nn12_distances)

    threshold = 0.35
    mask = (lowe_r < threshold)

    im1_pts = interest_points1[mask]

    nn12 = np.array(nn12)
    nn12 = nn12[mask]

    im2_pts = nn12[:, 0]
    #print(im1_pts)
    H_1_to_2 = computeH_1_to_2(im1_pts, im2_pts)

    
    im1 = skio.imread(im1name) 
    im1 = im1.astype(np.float32) / 255.0

    im2 = skio.imread(im2name) 
    im2 = im2.astype(np.float32) / 255.0

    canvas = draw_images_side_by_side(im1, im1_pts, im2, im2_pts)

    #plt.imsave('data/library/match.jpg', canvas)

    plt.imshow(canvas)
    plt.show()


def RANSAC(im1_pts, im2_pts, error_threshold = 2):
    n = len(im1_pts)
    max_iters = 1000
    sample_size = 4

     #3 pixels

    ## convert to homogeneous coordinates
    ones = np.ones((im1_pts.shape[0], 1))
    im1_pts = np.hstack([im1_pts, ones])
    im2_pts = np.hstack([im2_pts, ones])

    best_inliers = np.full((im1_pts.shape[0]), False)

    for i in range(max_iters):
        four_pts_idx = random.sample(range(len(im1_pts)), sample_size)
        four_pts1 = im1_pts[four_pts_idx]
        four_pts2 = im2_pts[four_pts_idx]

        H_1_to_2 = computeH_1_to_2(four_pts1[:, :2], four_pts2[:, :2])
        
        pts_1_to_2 = (H_1_to_2 @ im1_pts.T).T
        pts_1_to_2 = pts_1_to_2[:, :3] / pts_1_to_2[:, 2:3]  # normalize by homogenous coordinate
        
        error = np.linalg.norm(pts_1_to_2[:, :2] - im2_pts[:, :2], axis=1) #compute error only on y,x not homogenous coordinate
        inliers = error < error_threshold

        if np.sum(inliers) > np.sum(best_inliers):
            best_inliers = inliers
    
    if np.sum(best_inliers) < 4:
        return None
    
    im1_pts = im1_pts[:, :2]
    im2_pts = im2_pts[:, :2]
    

    H = computeH_1_to_2(im1_pts[best_inliers], im2_pts[best_inliers])
    return H, best_inliers

def partB4():
    #im1name = 'data/tennis/IMG_2891.jpg'
    #im2name = 'data/tennis/IMG_2892.jpg'
    #im3name = 'data/tennis/IMG_2893.jpg'

    #im1name = 'data/neighborhood/IMG_2885.jpg'
    #im2name = 'data/neighborhood/IMG_2886.jpg'
    #im3name = 'data/neighborhood/IMG_2887.jpg'

    im1name = 'data/library/IMG_2875.jpg'
    im2name = 'data/library/IMG_2876.jpeg'
    im3name = 'data/library/IMG_2877.jpg'

    im1 = skio.imread(im1name, as_gray=True) 
    im1 = im1.astype(np.float32) / 255.0

    im2 = skio.imread(im2name, as_gray=True) 
    im2 = im2.astype(np.float32) / 255.0

    im3 = skio.imread(im3name, as_gray=True)
    im3 = im3.astype(np.float32) / 255.0

    h1, coords1 = get_harris_corners(im1)
    interest_points1 = ANMS(h1, coords1.T, 500)
    samples1 = get_feature_samples(im1, interest_points1)

    h2, coords2 = get_harris_corners(im2)
    interest_points2 = ANMS(h2, coords2.T, 500)
    samples2 = get_feature_samples(im2, interest_points2)

    h3, coords3 = get_harris_corners(im3)
    interest_points3 = ANMS(h3, coords3.T, 500)
    samples3 = get_feature_samples(im3, interest_points3)

    nn12, nn12_distances = nearest_neighbors12(samples1, samples2, interest_points2)
    lowe_r = lowe_ratio(nn12_distances)
    threshold = 0.35
    mask = (lowe_r < threshold)
    im1_pts = interest_points1[mask]
    nn12 = np.array(nn12)
    nn12 = nn12[mask]
    im2_pts = nn12[:, 0]

    nn32, nn32_distances = nearest_neighbors12(samples3, samples2, interest_points2)
    lowe_r = lowe_ratio(nn32_distances)
    mask = (lowe_r < threshold)
    im3_pts = interest_points3[mask]
    nn32 = np.array(nn32)
    nn32 = nn32[mask]
    im2_pts2 = nn32[:, 0]

    H_1_to_2, best_inliers = RANSAC(im1_pts[:, ::-1], im2_pts[:, ::-1]) ## swap xy -> yx
    
    # get images again as color images
    im1 = skio.imread(im1name) 
    im1 = im1.astype(np.float32) / 255.0
    im2 = skio.imread(im2name) 
    im2 = im2.astype(np.float32) / 255.0
    im3 = skio.imread(im3name) 
    im3 = im3.astype(np.float32) / 255.0

    blend, H_im2_to_canvas  = stitch_alphablend(im1, im2, H_1_to_2) #original

    H_3_to_2, _ = RANSAC(im3_pts[:, ::-1], im2_pts2[:, ::-1])



    #im3, im3_warp, im2, H_3_to_2 = mosaic(im3name, im2name, im3_pts, im2_pts2)

    full_blend, _ = stitch_alphablend(im3, blend, H_im2_to_canvas @ H_3_to_2)

    #im2_warp = warpImageBilinear(im2, H_im2_to_canvas)

    #plt.imsave('data/library/ransac.jpg', full_blend)

    show_images([im1, im2, blend, full_blend])

def partB5():
    im1name = 'data/library/IMG_2875.jpg'
    im1 = skio.imread(im1name, as_gray=True) 
    im1 = im1.astype(np.float32) / 255.0

    im2name = 'data/library/IMG_2876.jpeg'
    im2 = skio.imread(im2name, as_gray=True) 
    im2 = im2.astype(np.float32) / 255.0

    h1, coords1 = get_harris_corners(im1)
    interest_points1 = ANMS(h1, coords1.T, 500)
    samples1 = get_rotation_invariant_feature_samples(im1, interest_points1)
    samples3 = get_feature_samples(im1, interest_points1)

    h2, coords2 = get_harris_corners(im2)
    interest_points2 = ANMS(h2, coords2.T, 500)
    samples2 = get_rotation_invariant_feature_samples(im2, interest_points2)
    samples4 = get_feature_samples(im2, interest_points2)

    H, best_inliers = RANSAC(interest_points1, interest_points2)
    #samples1 = samples1[best_inliers]
    #samples2 = samples2[best_inliers]
    
    for i in range(len(best_inliers)):
        if best_inliers[i]:
            print(i)
            show_images([samples1[i], samples2[i], samples3[i], samples4[i]])
            #plt.imsave(f'data/library/rot{i}_{1}.jpg', samples1[i], cmap='gray')
            #plt.imsave(f'data/library/rot{i}_{2}.jpg', samples2[i], cmap='gray')
            #plt.imsave(f'data/library/rot{i}_{3}.jpg', samples3[i], cmap='gray')
            #plt.imsave(f'data/library/rot{i}_{4}.jpg', samples4[i], cmap='gray') 




#partA3()
#partA4()
#mosaic()
#cylindrical_mosaic()
#rectify()

#partB1
#partB2()
#partB3()
#partB4()
#partB5()













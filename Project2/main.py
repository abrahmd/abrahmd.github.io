import numpy as np
import skimage as sk
import skimage.io as skio
import matplotlib.pyplot as plt
from scipy.signal import convolve2d
import cv2
import math
from hybrid_python.align_image_code import align_images
from PIL import Image
from matplotlib.path import Path

def convolve_four_loops(im, kernel) -> np.array:
    kernel = np.flip(kernel)
    im_convolved = np.zeros((im.shape[0], im.shape[1]))
    im = np.pad(im, ((1,1),(1,1)), 'constant')
    for y in range(1, im.shape[0]-1):
        for x in range(1, im.shape[1]-1):
            sum = 0.0
            y_lo = y - kernel.shape[0] // 2
            y_hi = y + kernel.shape[0] // 2 + 1
            x_lo = x - kernel.shape[1] // 2
            x_hi = x + kernel.shape[1] // 2 + 1
            if y_lo >= 0 and y_hi <= im.shape[0] and x_lo >= 0 and x_hi <= im.shape[1]:
                for yk in range(kernel.shape[0]):
                    for xk in range(kernel.shape[1]):
                        pixel = im[y - kernel.shape[0]//2 + yk, x - kernel.shape[1]//2 + xk]
                        sum += pixel * kernel[yk, xk]
            im_convolved[y-1, x-1] = sum
    
    return im_convolved

def convolve_two_loops(im, kernel) -> np.array:
    kernel = np.flip(kernel)
    im_convolved = np.zeros((im.shape[0], im.shape[1]))
    im = np.pad(im, ((1,1),(1,1)), 'constant')
    for y in range(1, im.shape[0]-1):
        for x in range(1, im.shape[1]-1):
            y_lo = y - kernel.shape[0] // 2
            y_hi = y + kernel.shape[0] // 2 + 1
            x_lo = x - kernel.shape[1] // 2
            x_hi = x + kernel.shape[1] // 2 + 1
            if y_lo >= 0 and y_hi <= im.shape[0] and x_lo >= 0 and x_hi <= im.shape[1]:
                im_convolved[y-1][x-1] = np.sum(kernel * im[y_lo: y_hi, x_lo:x_hi])

    return im_convolved

"""
    Helper method generated by chatgpt.
"""
def show_images(images, titles=None, cols=3, same_scale=False):
    n = len(images)
    rows = math.ceil(n / cols)
    fig, axs = plt.subplots(rows, cols, figsize=(4*cols, 4*rows))
    axs = np.atleast_1d(axs).ravel()

    # Optional: consistent grayscale scaling across all images
    vmin = vmax = None
    if same_scale:
        vals = [im for im in images if im.ndim == 2]
        if vals:
            vmin = min(float(x.min()) for x in vals)
            vmax = max(float(x.max()) for x in vals)

    for i, im in enumerate(images):
        if im.ndim == 2:
            axs[i].imshow(im, cmap='gray', vmin=vmin, vmax=vmax)
        else:
            axs[i].imshow(im)  # RGB
        if titles: axs[i].set_title(titles[i])
        axs[i].axis('off')

    # Hide any empty slots
    for j in range(i+1, rows*cols):
        axs[j].axis('off')

    plt.tight_layout(); plt.show()

def part1_1():
    imname = 'data/BW_self.jpg'
    im = skio.imread(imname) 
    im = im.astype(np.float32) / 255.0

    box_filter = 1.0/9 * np.ones((9,9))
    dx = np.array([-1, 0, 1]).reshape(1,-1) / 2
    dy = np.array([-1, 0, 1]).reshape(-1,1) / 2

    im_boxf = convolve_four_loops(im, box_filter)
    im_dx = convolve_four_loops(im, dx)
    im_dy = convolve_four_loops(im, dy)

    #plt.imsave(f'data/BW_self_boxfiltered.jpg', im_boxf, cmap='gray')
    plt.imshow(im_boxf, cmap='gray')
    plt.show()

    #plt.imsave(f'data/BW_selfDX.jpg', im_dx, cmap='gray')
    plt.imshow(im_dx, cmap='gray')
    plt.show()

    #plt.imsave(f'data/BW_selfDY.jpg', im_dy, cmap='gray')
    plt.imshow(im_dy, cmap='gray')
    plt.show()

def part1_2():
    imname = 'data/cameraman.jpg'
    im = skio.imread(imname) 
    im = im[:,:,0] #black and white
    im = np.pad(im, (1,1), mode='edge')

    dx = np.array([[0, 0, 0],
                   [-1, 0, 1],
                   [0, 0, 0]]) / 2
    dy = np.array([[0, 1, 0],
                   [0, 0, 0],
                   [0,-1, 0]]) / 2
    

    im_dx = convolve2d(im, dx)
    im_dy = convolve2d(im, dy)

    im_gradmag = np.sqrt(im_dx**2 + im_dy**2)

    plt.imshow(im_gradmag, cmap='gray')
    plt.show()

    threshold = 45
    mask = (im_gradmag > threshold)
    im_gradmag_bin = np.zeros_like(im_gradmag)
    im_gradmag_bin[mask] = 255


    #plt.imsave(f'data/cameraman_gradmag.jpg', im_gradmag_bin, cmap='gray')
    plt.imshow(im_gradmag_bin, cmap='gray')
    plt.show()

"""
What difference do you see? -> Less noise = lower threshold
"""
def part1_3():
    imname = 'data/cameraman.jpg'
    im = skio.imread(imname) 
    im = im[:,:,0] #black and white
    im = np.pad(im, (1,1), mode='edge')

    G = cv2.getGaussianKernel(ksize=5, sigma=2/3)
    G = G @ G.T
    
    
    dx = np.array([[0, 0, 0],
                   [-1, 0, 1],
                   [0, 0, 0]]) / 2
    dy = np.array([[0, 1, 0],
                   [0, 0, 0],
                   [0,-1, 0]]) / 2
    
    im_G = convolve2d(im, G)
    im_Gdx = convolve2d(im_G, dx)
    im_Gdy = convolve2d(im_G, dy)

    im_gradmag = np.sqrt(im_Gdx**2 + im_Gdy**2)

    #plt.imsave(f'data/cameraman_noT.jpg', im_gradmag, cmap='gray')
    plt.imshow(im_gradmag, cmap='gray')
    plt.show()

    threshold = 35
    mask = (im_gradmag > threshold)
    im_gradmag_bin = np.zeros_like(im_gradmag)
    im_gradmag_bin[mask] = 255

    plt.imshow(im_gradmag_bin, cmap='gray')
    plt.show()

    ########################### 
    
    ## Aproach 1
    G_dx = convolve2d(G, dx) ### This seems to work
    G_dy = convolve2d(G, dy)
    
    im_Gdx = convolve2d(im, G_dx)
    im_Gdy = convolve2d(im, G_dy)

    im_gradmag = np.sqrt(im_Gdx**2 + im_Gdy**2)
    
    threshold = 10
    mask = (im_gradmag > threshold)
    im_Gdxdy_bin = np.zeros_like(im_gradmag)
    im_Gdxdy_bin[mask] = 255    
    #plt.imsave(f'data/cameraman_Ggradman10.jpg', im_Gdxdy_bin, cmap='gray')

    threshold = 25
    mask = (im_gradmag > threshold)
    im_Gdxdy_bin = np.zeros_like(im_gradmag)
    im_Gdxdy_bin[mask] = 255    
    #plt.imsave(f'data/cameraman_Ggradman20.jpg', im_Gdxdy_bin, cmap='gray')

    threshold = 40
    mask = (im_gradmag > threshold)
    im_Gdxdy_bin = np.zeros_like(im_gradmag)
    im_Gdxdy_bin[mask] = 255    
    #plt.imsave(f'data/cameraman_Ggradman40.jpg', im_Gdxdy_bin, cmap='gray')

    plt.imshow(im_Gdxdy_bin, cmap='gray')
    plt.show()

def part1_BW():
    imname = 'data/BW_self.jpg'
    im = skio.imread(imname) 
    im = im.astype(np.float32) / 255.0

    dx = np.array([[0, 0, 0],
                   [-1, 0, 1],
                   [0, 0, 0]]) / 2
    dy = np.array([[0, 1, 0],
                   [0, 0, 0],
                   [0,-1, 0]]) / 2
    
    im_dx = convolve2d(im, dx)
    im_dy = convolve2d(im, dy)

    theta = np.arctan2(im_dy, im_dx)  # direciton of the gradient magnitude
    theta_norm = (theta + np.pi) / (2*np.pi) 

    im_gradmag = np.sqrt(im_dx**2 + im_dy**2)
    im_gradmag_norm = (im_gradmag - np.min(im_gradmag)) / (np.max(im_gradmag) - np.min(im_gradmag))

    h = theta_norm
    s = np.clip(im_gradmag_norm, 0.0, 1.0) 
    v = np.clip(im_gradmag_norm, 0.0, 1.0)

    hsv = np.stack([h, s, v], axis=2)
    rgb =  sk.color.hsv2rgb(hsv)

    #plt.imsave(f'data/hsv.jpg', rgb)

    show_images([rgb])


    
### Oberserve that in the final part, we get the original image, mathematically they are equivalent
def part2_1(imname):
    im = skio.imread(imname) 
    im_c = im[:,:,:3]
    im_c = np.pad(im_c, ((1,1), (1,1), (0,0)), mode='edge')

    im_c = im_c.astype(np.float32) / 255.0

    G = cv2.getGaussianKernel(ksize=13, sigma=2)
    G = G @ G.T
        
    
    im_blur_r = convolve2d(im_c[:,:,0], G, mode='same')
    im_blur_g = convolve2d(im_c[:,:,1], G, mode='same')
    im_blur_b = convolve2d(im_c[:,:,2], G, mode='same')

    im_blur = np.stack([im_blur_r, im_blur_g, im_blur_b], axis=2)
    im_blur = np.clip(im_blur, 0, 1)

    

    im_highfreq = im_c - im_blur

    im_sharp = im_c + im_highfreq
    im_sharp = np.clip(im_sharp, 0, 1)

    im_blur_sharp = im_blur + im_highfreq

    im_highfreq -= np.min(im_highfreq)
    im_highfreq /= np.max(im_highfreq)


    #plt.imsave(f'data/lights_blur.jpg', im_blur)
    #plt.imsave(f'data/lights_sharp.jpg', im_sharp)
    plt.imsave(f'data/taj_highfrequencies.jpg', im_highfreq)
    #plt.imsave(f'data/lights_bs.jpg', im_blur_sharp)


    show_images([im_blur, im_sharp, im_highfreq, im_blur_sharp])

def part2_2x():
    im1 = 'data/trump.jpg'
    im2 = 'data/cry.jpg'

    im1 = skio.imread(im1) 
    im2 = skio.imread(im2)

    im3, im4 = align_images(im2, im1)

    im3 = (im3 * 255).astype(np.uint8)
    #im4 = (im4 * 255).astype(np.uint8)

    G1 = cv2.getGaussianKernel(ksize=10, sigma=5)
    G1 = G1 @ G1.T

    G2 = cv2.getGaussianKernel(ksize=10, sigma=5)
    G2 = G2 @ G2.T


    im3_blur_r = convolve2d(im3[:,:,0], G1, mode='same').astype(np.uint8)
    im3_blur_g = convolve2d(im3[:,:,1], G1, mode='same').astype(np.uint8)
    im3_blur_b = convolve2d(im3[:,:,2], G1, mode='same').astype(np.uint8)
    im3_blur = np.stack([im3_blur_r, im3_blur_g, im3_blur_b], axis=2)

    show_images([im3, im3_blur_r, im3_blur_g, im3_blur_b, im3_blur])

    im4_blur_r = convolve2d(im4[:,:,0], G2, mode='same').astype(np.uint8)
    im4_blur_g = convolve2d(im4[:,:,1], G2, mode='same').astype(np.uint8)
    im4_blur_b = convolve2d(im4[:,:,2], G2, mode='same').astype(np.uint8)
    im4_blur = np.stack([im4_blur_r, im4_blur_g, im4_blur_b], axis=2)

    im4_highfreq = im4.astype(np.int32) - im4_blur.astype(np.int32)
    im4_highfreq = 4 * np.clip(im4_highfreq, 0, 255).astype(np.uint8)

    im5 = im3_blur.astype(np.int32) + im4_highfreq.astype(np.int32)
    im5 = np.clip(im5, 0, 255).astype(np.uint8)


    show_images([im3, im4, im3_blur, im4_highfreq, im5])


"""
Align images
"""
def part2_21(im1, im2):
    im1 = skio.imread(im1) 
    im2 = skio.imread(im2)

    im3, im4 = align_images(im2, im1)

    im4 = im4.astype(np.float32) / 255.0

    im4 -= np.min(im4)
    im4 /= np.max(im4)
    
    #im3 = cv2.cvtCo
    # lor(im3, cv2.COLOR_RGB2BGR) #im3 is CAT
    im3 = im3[:,:,0] #im3 is me
    #im4 = cv2.cvtColor(im4, cv2.COLOR_RGB2BGR) # im4 is MAN
    im4 = im4[:,:,0]

    G1 = cv2.getGaussianKernel(ksize=70, sigma=12) 
    G1 = G1 @ G1.T

    G2 = cv2.getGaussianKernel(ksize=70, sigma=20)
    G2 = G2 @ G2.T

    im3_blur = convolve2d(im3, G1, mode='same')
    im4_blur = convolve2d(im4, G2, mode='same')

    im3_highfreq = im3 - im3_blur
    #im3_highfreq = np.clip(im3_highfreq, 0, 255).astype(np.uint8)

    im5 = im4_blur + im3_highfreq
    #im5 = np.clip(im5, 0, 1)
    im5 -= np.min(im5)
    im5 /= np.max(im5)
    
    im3_highfreq -= np.min(im3_highfreq)
    im3_highfreq /= np.max(im3_highfreq)

    """
    plt.imsave(f'data/lazaro.jpg', im1, cmap='gray')
    plt.imsave(f'data/me.jpg', im2, cmap='gray')
    plt.imsave(f'data/me_hf.jpg', im3_highfreq, cmap='gray')
    plt.imsave(f'data/laz_blur.jpg', im4_blur, cmap='gray')
    plt.imsave(f'data/hybrid_melaz.jpg', im5, cmap='gray') """

    show_images([im3, im4, im3_blur, im3_highfreq, im4_blur, im5])

"""
Frequency analysis - show Fourier transform of input images, filtered images, hybrid image
"""
def part2_22(im1, im2):

    im1 = skio.imread(im1) 
    im2 = skio.imread(im2)

    im1 = im1.astype(np.float32) / 255.0

    im1_aligned, im2_aligned = align_images(im2, im1)

    im1_aligned_bw = im1_aligned[:,:,0]
    im2_aligned_bw = im2_aligned[:,:,0]

    G1 = cv2.getGaussianKernel(ksize=73, sigma=12) ## for the cat, LOW PASS ONLY
    G1 = G1 @ G1.T

    G2 = cv2.getGaussianKernel(ksize=72, sigma=12) ## for the man
    G2 = G2 @ G2.T


    im1_al_bw_blur = convolve2d(im1_aligned_bw, G1, mode='same')
    im2_al_bw_blur = convolve2d(im2_aligned_bw, G2, mode='same')

    im1_al_bw_highfq = im1_aligned_bw - im1_al_bw_blur
    #im1_al_bw_blur_highfq = np.clip(im1_al_bw_blur_highfq, 0, 255)

    im_hybrid = im2_al_bw_blur + im1_al_bw_highfq
    #im_hybrid = np.clip(im_hybrid, 0, 255).astype(np.uint8)

    im1_fourier = np.log(np.abs(np.fft.fftshift(np.fft.fft2(im1_aligned_bw))))
    im2_fourier = np.log(np.abs(np.fft.fftshift(np.fft.fft2(im2_aligned_bw))))

    im1_filter_fourier = np.log(np.abs(np.fft.fftshift(np.fft.fft2(im1_al_bw_highfq))))
    im2_filter_fourier = np.log(np.abs(np.fft.fftshift(np.fft.fft2(im2_al_bw_blur))))

    im_hybrid_fourier = np.log(np.abs(np.fft.fftshift(np.fft.fft2(im_hybrid))))

    """
    plt.imsave(f'data/baby_f.jpg', im1_fourier, cmap='gray')
    plt.imsave(f'data/trump_f.jpg', im2_fourier, cmap='gray')
    plt.imsave(f'data/baby_tf.jpg', im1_filter_fourier, cmap='gray')
    plt.imsave(f'data/trump_tf.jpg', im2_filter_fourier, cmap='gray')
    plt.imsave(f'data/hyrbid_f.jpg', im_hybrid_fourier, cmap='gray') """


    show_images([im1_fourier, im2_fourier, im1_filter_fourier, im2_filter_fourier, im_hybrid_fourier])

def part2_BW():
    im1 = 'data/trump.jpg'
    im2 = 'data/cry.jpg'
    
    im1 = skio.imread(im1) 
    im2 = skio.imread(im2)

    im3, im4 = align_images(im2, im1)

    im4 = im4.astype(np.float32) / 255.0

    im4 -= np.min(im4)
    im4 /= np.max(im4)

    G1 = cv2.getGaussianKernel(ksize=49, sigma=8) 
    G1 = G1 @ G1.T
    
    im3_blur_r = convolve2d(im3[:,:,0], G1, mode='same')
    im3_blur_g = convolve2d(im3[:,:,1], G1, mode='same')
    im3_blur_b = convolve2d(im3[:,:,2], G1, mode='same')
    im3_blur = np.stack([im3_blur_r, im3_blur_g, im3_blur_b], axis=2)
    
    im4_blur_r = convolve2d(im4[:,:,0], G1, mode='same')
    im4_blur_g = convolve2d(im4[:,:,1], G1, mode='same')
    im4_blur_b = convolve2d(im4[:,:,2], G1, mode='same')
    im4_blur = np.stack([im4_blur_r, im4_blur_g, im4_blur_b], axis=2)

    


    
    im3_highfreq = im3 - im3_blur
    #im3_highfreq = np.clip(im3_highfreq, 0, 255).astype(np.uint8)

    im5 = im4_blur + im3_highfreq
    #im5 = np.clip(im5, 0, 1)
    im5 -= np.min(im5)
    im5 /= np.max(im5)
    
    im3_highfreq -= np.min(im3_highfreq)
    im3_highfreq /= np.max(im3_highfreq)

    #plt.imsave('data/babytrump_color3.jpg', im5)

    show_images([im3, im4, im3_blur, im3_highfreq, im4_blur, im5])


def create_gaussian_stack(im, n_levels):
    G = cv2.getGaussianKernel(ksize=19, sigma=3).astype(np.float32)
    G = G @ G.T
    stack = [im]
    for i in range(n_levels-1):
        im_blur_r = convolve2d(im[:,:,0], G, mode='same')#.astype(np.uint8)
        im_blur_g = convolve2d(im[:,:,1], G, mode='same')#.astype(np.uint8)
        im_blur_b = convolve2d(im[:,:,2], G, mode='same')#.astype(np.uint8)
        im_blur = np.stack([im_blur_r, im_blur_g, im_blur_b], axis=2)
        stack.append(im_blur)
        im = im_blur
    return stack


def create_laplacian_stack(gaussian_stack):
    stack = []
    for i in range(len(gaussian_stack)-1):
        dif = gaussian_stack[i] - gaussian_stack[i+1]
        #normalization ???
        #dif = dif - np.min(dif)
        #dif = dif / np.max(dif)

        stack.append(dif)
    stack.append(gaussian_stack[-1])#.astype(np.float32))
    return stack

def part2_3():
    #create gaussian stack
    im1 = 'data/apple.jpeg'
    im2 = 'data/orange.jpeg'

    im1 = skio.imread(im1).astype(np.float32) / 255.0
    im2 = skio.imread(im2).astype(np.float32) / 255.0

    n_levels = 4
    im1_gaussian_stack = create_gaussian_stack(im1, n_levels)
    im1_laplacian_stack = create_laplacian_stack(im1_gaussian_stack)

    im2_gaussian_stack = create_gaussian_stack(im2, n_levels)
    im2_laplacian_stack = create_laplacian_stack(im2_gaussian_stack)

    show_images(im1_gaussian_stack + im1_laplacian_stack)
    show_images(im2_gaussian_stack + im2_laplacian_stack)



def floats_to_255(stack):
    for i in range(len(stack)): #scaling
        maxv = np.max(np.abs(stack[i])) + 1e-8
        stack[i] = (np.clip(0.5 + 0.5*(stack[i]/maxv), 0, 1) * 255).astype(np.uint8)
    """
    for i in range(len(stack)):
        im = stack[i]
        im += np.min(im)
        im /= (np.max(im) + np.min(im))
        im *= 255
        stack[i] = im.astype(np.uint8)
    """
    return stack

def part2_4(im1, im2, mask):

    n_levels = 4
    im1_gstack = create_gaussian_stack(im1, n_levels)
    im1_lstack = create_laplacian_stack(im1_gstack)

    im2_gstack = create_gaussian_stack(im2, n_levels)
    im2_lstack = create_laplacian_stack(im2_gstack)

    mask_gstack = create_gaussian_stack(mask, 12)
    mask_gstack = mask_gstack[-n_levels:]

    hybrid_lstack = []
    for i in range(n_levels-1, -1, -1): 
        im1_masked = mask_gstack[i] * im1_lstack[i]
        im2_masked = (1-mask_gstack[i]) * im2_lstack[i]
        res =  im1_masked + im2_masked
        hybrid_lstack.append(res)


    im = np.zeros_like(im1).astype(np.float32)
    for i in range(len(hybrid_lstack)):
        im += hybrid_lstack[i]

    #im1_gstack = floats_to_255(im1_gstack)
    #im2_gstack = floats_to_255(im2_gstack)
    #im1_lstack = floats_to_255(im1_lstack)
    #im2_lstack = floats_to_255(im2_lstack)
    show_images(im1_gstack + im1_lstack)
    show_images(im2_gstack + im2_lstack)
    show_images([im] + hybrid_lstack)

    im = np.clip(im, 0, 1)
    plt.imsave('data/cokeapple.jpg', im)

def pepsi_coke():
    coke = 'data/coke.jpeg'
    pepsi = 'data/pepsi.png'
    im1 = skio.imread(coke).astype(np.float32) / 255.0
    im2 = skio.imread(pepsi).astype(np.float32) / 255.0
    
    mask = np.zeros_like(im1)
    mask[:, :mask.shape[1]//2] = 1

    part2_4(im1, im2, mask)

def oraple():
    coke = 'data/apple.jpeg'
    pepsi = 'data/orange.jpeg'
    im1 = skio.imread(coke).astype(np.float32) / 255.0
    im2 = skio.imread(pepsi).astype(np.float32) / 255.0

    mask = np.zeros_like(im1)
    mask[:, :mask.shape[1]//2] = 1

    part2_4(im1, im2, mask)


"""
Helper method for creating a custom mask, generated by chatgpt
"""
def create_custom_mask():
    image_path = 'data/dog.jpg'
    image = np.array(Image.open(image_path))
    height, width = image.shape[:2]

    fig, ax = plt.subplots()
    ax.imshow(image)
    ax.set_title("Click to outline dog's face. Close the window when done.")

    polygon_points = []

    def on_click(event):
        if event.xdata is not None and event.ydata is not None:
            polygon_points.append((event.xdata, event.ydata))
            ax.plot(event.xdata, event.ydata, 'ro')  # show the point
            fig.canvas.draw()

    cid = fig.canvas.mpl_connect('button_press_event', on_click)
    plt.show()
    if len(polygon_points) >= 3:
        polygon = np.array(polygon_points)
        x, y = np.meshgrid(np.arange(width), np.arange(height))
        x, y = x.flatten(), y.flatten()
        points = np.vstack((x, y)).T
        path = Path(polygon)
        mask_flat = path.contains_points(points)
        mask = mask_flat.reshape((height, width)).astype(np.uint8)

        return mask

"""
    Must click to create a custom mask
"""
def waterdog():
    watermelon = 'data/watermelon.jpg'
    dog = 'data/dog.jpg'
    im1 = skio.imread(watermelon).astype(np.float32) / 255.0
    im2 = skio.imread(dog).astype(np.float32) / 255.0

    mask = create_custom_mask()
    mask = 1-mask
    mask = np.stack([mask, mask, mask], axis=2)
    
    part2_4(im1, im2, mask)

def cokeapple():
    apple = 'data/apple.jpeg'
    coke = 'data/coke.jpeg'
    im1 = skio.imread(apple).astype(np.float32) / 255.0
    im2 = skio.imread(coke).astype(np.float32) / 255.0

    show_images([im1,im2])

    pad = np.full((40, im2.shape[1], 3), 255)
    im2 = np.vstack([pad, im2])
    im2 = cv2.resize(im2, (im1.shape[0], im1.shape[1]), interpolation=cv2.INTER_AREA)

    mask = np.zeros_like(im1)
    mask[:, :mask.shape[1]//2] = 1

    part2_4(im1, im2, mask)

def cokeapple_blend():
    apple = 'data/apple.jpeg'
    coke = 'data/coke.jpeg'
    im1 = skio.imread(apple).astype(np.float32) / 255.0
    im2 = skio.imread(coke).astype(np.float32) / 255.0

    pad = np.full((40, im2.shape[1], 3), 255)
    im2 = np.vstack([pad, im2])
    im2 = cv2.resize(im2, (im1.shape[0], im1.shape[1]), interpolation=cv2.INTER_AREA)

    mask = (im2[:,:,0] <= 0.95) & (im2[:,:,1] <= 0.95) & (im2[:,:,2] <= 0.95) & (im2[:,:,2] <= 0.95)
    #mask = (mask > 0)




    im2_c = im2.copy()
    im2_c[:,:,0][mask] = im2[:,:,0][mask] * (2.0/3.0)
    im2_c[:,:,1][mask] = im2[:,:,0][mask] * (1.0/3.0)
    #im2 = im2_c

    show_images([im2, im2_c, mask])

    mask = np.zeros_like(im1)
    mask[:, :mask.shape[1]//2] = 1
    part2_4(im1, im2_c, mask)



def main():
    #part1_1()
    #part1_2()
    #part1_3()
    #part1_BW()

    #part2_1('data/taj.jpg')
    #part2_1('data/lights.png')

    #part2_21('data/cry.jpg', 'data/trump.jpg')
    #part2_22('data/cry.jpg', 'data/trump.jpg')
    #part2_22('data/lazaro.jpeg', 'data/me.jpeg')
    #part2_BW()

    #part2_3()

    #### part 2.4 ####
    #oraple()
    #pepsi_coke()
    #waterdog()
    cokeapple()
    #cokeapple_blend()
    pass


if __name__ == "__main__":
    main()


